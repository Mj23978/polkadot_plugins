// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'own_stash_info.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

OwnStashInfo _$OwnStashInfoFromJson(Map<String, dynamic> json) {
  return _OwnStashInfo.fromJson(json);
}

/// @nodoc
class _$OwnStashInfoTearOff {
  const _$OwnStashInfoTearOff();

  _OwnStashInfo call(
      {LedgerInfo? account,
      String? controllerId,
      String? destination,
      int? destinationId,
      Map<String, dynamic>? exposure,
      String? hexSessionIdNext,
      String? hexSessionIdQueue,
      bool? isOwnController,
      bool? isOwnStash,
      bool? isStashNominating,
      bool? isStashValidating,
      List<String>? nominating,
      List<String>? sessionIds,
      Map<String, dynamic>? stakingLedger,
      String? stashId,
      Map<String, dynamic>? validatorPrefs,
      NomineesInfo? inactives,
      Map<String, dynamic>? unbondings}) {
    return _OwnStashInfo(
      account: account,
      controllerId: controllerId,
      destination: destination,
      destinationId: destinationId,
      exposure: exposure,
      hexSessionIdNext: hexSessionIdNext,
      hexSessionIdQueue: hexSessionIdQueue,
      isOwnController: isOwnController,
      isOwnStash: isOwnStash,
      isStashNominating: isStashNominating,
      isStashValidating: isStashValidating,
      nominating: nominating,
      sessionIds: sessionIds,
      stakingLedger: stakingLedger,
      stashId: stashId,
      validatorPrefs: validatorPrefs,
      inactives: inactives,
      unbondings: unbondings,
    );
  }

  OwnStashInfo fromJson(Map<String, Object?> json) {
    return OwnStashInfo.fromJson(json);
  }
}

/// @nodoc
const $OwnStashInfo = _$OwnStashInfoTearOff();

/// @nodoc
mixin _$OwnStashInfo {
  LedgerInfo? get account => throw _privateConstructorUsedError;
  String? get controllerId => throw _privateConstructorUsedError;
  String? get destination => throw _privateConstructorUsedError;
  int? get destinationId => throw _privateConstructorUsedError;
  Map<String, dynamic>? get exposure => throw _privateConstructorUsedError;
  String? get hexSessionIdNext => throw _privateConstructorUsedError;
  String? get hexSessionIdQueue => throw _privateConstructorUsedError;
  bool? get isOwnController => throw _privateConstructorUsedError;
  bool? get isOwnStash => throw _privateConstructorUsedError;
  bool? get isStashNominating => throw _privateConstructorUsedError;
  bool? get isStashValidating => throw _privateConstructorUsedError;
  List<String>? get nominating => throw _privateConstructorUsedError;
  List<String>? get sessionIds => throw _privateConstructorUsedError;
  Map<String, dynamic>? get stakingLedger => throw _privateConstructorUsedError;
  String? get stashId => throw _privateConstructorUsedError;
  Map<String, dynamic>? get validatorPrefs =>
      throw _privateConstructorUsedError;
  NomineesInfo? get inactives => throw _privateConstructorUsedError;
  Map<String, dynamic>? get unbondings => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $OwnStashInfoCopyWith<OwnStashInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OwnStashInfoCopyWith<$Res> {
  factory $OwnStashInfoCopyWith(
          OwnStashInfo value, $Res Function(OwnStashInfo) then) =
      _$OwnStashInfoCopyWithImpl<$Res>;
  $Res call(
      {LedgerInfo? account,
      String? controllerId,
      String? destination,
      int? destinationId,
      Map<String, dynamic>? exposure,
      String? hexSessionIdNext,
      String? hexSessionIdQueue,
      bool? isOwnController,
      bool? isOwnStash,
      bool? isStashNominating,
      bool? isStashValidating,
      List<String>? nominating,
      List<String>? sessionIds,
      Map<String, dynamic>? stakingLedger,
      String? stashId,
      Map<String, dynamic>? validatorPrefs,
      NomineesInfo? inactives,
      Map<String, dynamic>? unbondings});

  $LedgerInfoCopyWith<$Res>? get account;
  $NomineesInfoCopyWith<$Res>? get inactives;
}

/// @nodoc
class _$OwnStashInfoCopyWithImpl<$Res> implements $OwnStashInfoCopyWith<$Res> {
  _$OwnStashInfoCopyWithImpl(this._value, this._then);

  final OwnStashInfo _value;
  // ignore: unused_field
  final $Res Function(OwnStashInfo) _then;

  @override
  $Res call({
    Object? account = freezed,
    Object? controllerId = freezed,
    Object? destination = freezed,
    Object? destinationId = freezed,
    Object? exposure = freezed,
    Object? hexSessionIdNext = freezed,
    Object? hexSessionIdQueue = freezed,
    Object? isOwnController = freezed,
    Object? isOwnStash = freezed,
    Object? isStashNominating = freezed,
    Object? isStashValidating = freezed,
    Object? nominating = freezed,
    Object? sessionIds = freezed,
    Object? stakingLedger = freezed,
    Object? stashId = freezed,
    Object? validatorPrefs = freezed,
    Object? inactives = freezed,
    Object? unbondings = freezed,
  }) {
    return _then(_value.copyWith(
      account: account == freezed
          ? _value.account
          : account // ignore: cast_nullable_to_non_nullable
              as LedgerInfo?,
      controllerId: controllerId == freezed
          ? _value.controllerId
          : controllerId // ignore: cast_nullable_to_non_nullable
              as String?,
      destination: destination == freezed
          ? _value.destination
          : destination // ignore: cast_nullable_to_non_nullable
              as String?,
      destinationId: destinationId == freezed
          ? _value.destinationId
          : destinationId // ignore: cast_nullable_to_non_nullable
              as int?,
      exposure: exposure == freezed
          ? _value.exposure
          : exposure // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      hexSessionIdNext: hexSessionIdNext == freezed
          ? _value.hexSessionIdNext
          : hexSessionIdNext // ignore: cast_nullable_to_non_nullable
              as String?,
      hexSessionIdQueue: hexSessionIdQueue == freezed
          ? _value.hexSessionIdQueue
          : hexSessionIdQueue // ignore: cast_nullable_to_non_nullable
              as String?,
      isOwnController: isOwnController == freezed
          ? _value.isOwnController
          : isOwnController // ignore: cast_nullable_to_non_nullable
              as bool?,
      isOwnStash: isOwnStash == freezed
          ? _value.isOwnStash
          : isOwnStash // ignore: cast_nullable_to_non_nullable
              as bool?,
      isStashNominating: isStashNominating == freezed
          ? _value.isStashNominating
          : isStashNominating // ignore: cast_nullable_to_non_nullable
              as bool?,
      isStashValidating: isStashValidating == freezed
          ? _value.isStashValidating
          : isStashValidating // ignore: cast_nullable_to_non_nullable
              as bool?,
      nominating: nominating == freezed
          ? _value.nominating
          : nominating // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      sessionIds: sessionIds == freezed
          ? _value.sessionIds
          : sessionIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      stakingLedger: stakingLedger == freezed
          ? _value.stakingLedger
          : stakingLedger // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      stashId: stashId == freezed
          ? _value.stashId
          : stashId // ignore: cast_nullable_to_non_nullable
              as String?,
      validatorPrefs: validatorPrefs == freezed
          ? _value.validatorPrefs
          : validatorPrefs // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      inactives: inactives == freezed
          ? _value.inactives
          : inactives // ignore: cast_nullable_to_non_nullable
              as NomineesInfo?,
      unbondings: unbondings == freezed
          ? _value.unbondings
          : unbondings // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }

  @override
  $LedgerInfoCopyWith<$Res>? get account {
    if (_value.account == null) {
      return null;
    }

    return $LedgerInfoCopyWith<$Res>(_value.account!, (value) {
      return _then(_value.copyWith(account: value));
    });
  }

  @override
  $NomineesInfoCopyWith<$Res>? get inactives {
    if (_value.inactives == null) {
      return null;
    }

    return $NomineesInfoCopyWith<$Res>(_value.inactives!, (value) {
      return _then(_value.copyWith(inactives: value));
    });
  }
}

/// @nodoc
abstract class _$OwnStashInfoCopyWith<$Res>
    implements $OwnStashInfoCopyWith<$Res> {
  factory _$OwnStashInfoCopyWith(
          _OwnStashInfo value, $Res Function(_OwnStashInfo) then) =
      __$OwnStashInfoCopyWithImpl<$Res>;
  @override
  $Res call(
      {LedgerInfo? account,
      String? controllerId,
      String? destination,
      int? destinationId,
      Map<String, dynamic>? exposure,
      String? hexSessionIdNext,
      String? hexSessionIdQueue,
      bool? isOwnController,
      bool? isOwnStash,
      bool? isStashNominating,
      bool? isStashValidating,
      List<String>? nominating,
      List<String>? sessionIds,
      Map<String, dynamic>? stakingLedger,
      String? stashId,
      Map<String, dynamic>? validatorPrefs,
      NomineesInfo? inactives,
      Map<String, dynamic>? unbondings});

  @override
  $LedgerInfoCopyWith<$Res>? get account;
  @override
  $NomineesInfoCopyWith<$Res>? get inactives;
}

/// @nodoc
class __$OwnStashInfoCopyWithImpl<$Res> extends _$OwnStashInfoCopyWithImpl<$Res>
    implements _$OwnStashInfoCopyWith<$Res> {
  __$OwnStashInfoCopyWithImpl(
      _OwnStashInfo _value, $Res Function(_OwnStashInfo) _then)
      : super(_value, (v) => _then(v as _OwnStashInfo));

  @override
  _OwnStashInfo get _value => super._value as _OwnStashInfo;

  @override
  $Res call({
    Object? account = freezed,
    Object? controllerId = freezed,
    Object? destination = freezed,
    Object? destinationId = freezed,
    Object? exposure = freezed,
    Object? hexSessionIdNext = freezed,
    Object? hexSessionIdQueue = freezed,
    Object? isOwnController = freezed,
    Object? isOwnStash = freezed,
    Object? isStashNominating = freezed,
    Object? isStashValidating = freezed,
    Object? nominating = freezed,
    Object? sessionIds = freezed,
    Object? stakingLedger = freezed,
    Object? stashId = freezed,
    Object? validatorPrefs = freezed,
    Object? inactives = freezed,
    Object? unbondings = freezed,
  }) {
    return _then(_OwnStashInfo(
      account: account == freezed
          ? _value.account
          : account // ignore: cast_nullable_to_non_nullable
              as LedgerInfo?,
      controllerId: controllerId == freezed
          ? _value.controllerId
          : controllerId // ignore: cast_nullable_to_non_nullable
              as String?,
      destination: destination == freezed
          ? _value.destination
          : destination // ignore: cast_nullable_to_non_nullable
              as String?,
      destinationId: destinationId == freezed
          ? _value.destinationId
          : destinationId // ignore: cast_nullable_to_non_nullable
              as int?,
      exposure: exposure == freezed
          ? _value.exposure
          : exposure // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      hexSessionIdNext: hexSessionIdNext == freezed
          ? _value.hexSessionIdNext
          : hexSessionIdNext // ignore: cast_nullable_to_non_nullable
              as String?,
      hexSessionIdQueue: hexSessionIdQueue == freezed
          ? _value.hexSessionIdQueue
          : hexSessionIdQueue // ignore: cast_nullable_to_non_nullable
              as String?,
      isOwnController: isOwnController == freezed
          ? _value.isOwnController
          : isOwnController // ignore: cast_nullable_to_non_nullable
              as bool?,
      isOwnStash: isOwnStash == freezed
          ? _value.isOwnStash
          : isOwnStash // ignore: cast_nullable_to_non_nullable
              as bool?,
      isStashNominating: isStashNominating == freezed
          ? _value.isStashNominating
          : isStashNominating // ignore: cast_nullable_to_non_nullable
              as bool?,
      isStashValidating: isStashValidating == freezed
          ? _value.isStashValidating
          : isStashValidating // ignore: cast_nullable_to_non_nullable
              as bool?,
      nominating: nominating == freezed
          ? _value.nominating
          : nominating // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      sessionIds: sessionIds == freezed
          ? _value.sessionIds
          : sessionIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      stakingLedger: stakingLedger == freezed
          ? _value.stakingLedger
          : stakingLedger // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      stashId: stashId == freezed
          ? _value.stashId
          : stashId // ignore: cast_nullable_to_non_nullable
              as String?,
      validatorPrefs: validatorPrefs == freezed
          ? _value.validatorPrefs
          : validatorPrefs // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      inactives: inactives == freezed
          ? _value.inactives
          : inactives // ignore: cast_nullable_to_non_nullable
              as NomineesInfo?,
      unbondings: unbondings == freezed
          ? _value.unbondings
          : unbondings // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_OwnStashInfo extends _OwnStashInfo {
  const _$_OwnStashInfo(
      {this.account,
      this.controllerId,
      this.destination,
      this.destinationId,
      this.exposure,
      this.hexSessionIdNext,
      this.hexSessionIdQueue,
      this.isOwnController,
      this.isOwnStash,
      this.isStashNominating,
      this.isStashValidating,
      this.nominating,
      this.sessionIds,
      this.stakingLedger,
      this.stashId,
      this.validatorPrefs,
      this.inactives,
      this.unbondings})
      : super._();

  factory _$_OwnStashInfo.fromJson(Map<String, dynamic> json) =>
      _$$_OwnStashInfoFromJson(json);

  @override
  final LedgerInfo? account;
  @override
  final String? controllerId;
  @override
  final String? destination;
  @override
  final int? destinationId;
  @override
  final Map<String, dynamic>? exposure;
  @override
  final String? hexSessionIdNext;
  @override
  final String? hexSessionIdQueue;
  @override
  final bool? isOwnController;
  @override
  final bool? isOwnStash;
  @override
  final bool? isStashNominating;
  @override
  final bool? isStashValidating;
  @override
  final List<String>? nominating;
  @override
  final List<String>? sessionIds;
  @override
  final Map<String, dynamic>? stakingLedger;
  @override
  final String? stashId;
  @override
  final Map<String, dynamic>? validatorPrefs;
  @override
  final NomineesInfo? inactives;
  @override
  final Map<String, dynamic>? unbondings;

  @override
  String toString() {
    return 'OwnStashInfo(account: $account, controllerId: $controllerId, destination: $destination, destinationId: $destinationId, exposure: $exposure, hexSessionIdNext: $hexSessionIdNext, hexSessionIdQueue: $hexSessionIdQueue, isOwnController: $isOwnController, isOwnStash: $isOwnStash, isStashNominating: $isStashNominating, isStashValidating: $isStashValidating, nominating: $nominating, sessionIds: $sessionIds, stakingLedger: $stakingLedger, stashId: $stashId, validatorPrefs: $validatorPrefs, inactives: $inactives, unbondings: $unbondings)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _OwnStashInfo &&
            (identical(other.account, account) || other.account == account) &&
            (identical(other.controllerId, controllerId) ||
                other.controllerId == controllerId) &&
            (identical(other.destination, destination) ||
                other.destination == destination) &&
            (identical(other.destinationId, destinationId) ||
                other.destinationId == destinationId) &&
            const DeepCollectionEquality().equals(other.exposure, exposure) &&
            (identical(other.hexSessionIdNext, hexSessionIdNext) ||
                other.hexSessionIdNext == hexSessionIdNext) &&
            (identical(other.hexSessionIdQueue, hexSessionIdQueue) ||
                other.hexSessionIdQueue == hexSessionIdQueue) &&
            (identical(other.isOwnController, isOwnController) ||
                other.isOwnController == isOwnController) &&
            (identical(other.isOwnStash, isOwnStash) ||
                other.isOwnStash == isOwnStash) &&
            (identical(other.isStashNominating, isStashNominating) ||
                other.isStashNominating == isStashNominating) &&
            (identical(other.isStashValidating, isStashValidating) ||
                other.isStashValidating == isStashValidating) &&
            const DeepCollectionEquality()
                .equals(other.nominating, nominating) &&
            const DeepCollectionEquality()
                .equals(other.sessionIds, sessionIds) &&
            const DeepCollectionEquality()
                .equals(other.stakingLedger, stakingLedger) &&
            (identical(other.stashId, stashId) || other.stashId == stashId) &&
            const DeepCollectionEquality()
                .equals(other.validatorPrefs, validatorPrefs) &&
            (identical(other.inactives, inactives) ||
                other.inactives == inactives) &&
            const DeepCollectionEquality()
                .equals(other.unbondings, unbondings));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      account,
      controllerId,
      destination,
      destinationId,
      const DeepCollectionEquality().hash(exposure),
      hexSessionIdNext,
      hexSessionIdQueue,
      isOwnController,
      isOwnStash,
      isStashNominating,
      isStashValidating,
      const DeepCollectionEquality().hash(nominating),
      const DeepCollectionEquality().hash(sessionIds),
      const DeepCollectionEquality().hash(stakingLedger),
      stashId,
      const DeepCollectionEquality().hash(validatorPrefs),
      inactives,
      const DeepCollectionEquality().hash(unbondings));

  @JsonKey(ignore: true)
  @override
  _$OwnStashInfoCopyWith<_OwnStashInfo> get copyWith =>
      __$OwnStashInfoCopyWithImpl<_OwnStashInfo>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_OwnStashInfoToJson(this);
  }
}

abstract class _OwnStashInfo extends OwnStashInfo {
  const factory _OwnStashInfo(
      {LedgerInfo? account,
      String? controllerId,
      String? destination,
      int? destinationId,
      Map<String, dynamic>? exposure,
      String? hexSessionIdNext,
      String? hexSessionIdQueue,
      bool? isOwnController,
      bool? isOwnStash,
      bool? isStashNominating,
      bool? isStashValidating,
      List<String>? nominating,
      List<String>? sessionIds,
      Map<String, dynamic>? stakingLedger,
      String? stashId,
      Map<String, dynamic>? validatorPrefs,
      NomineesInfo? inactives,
      Map<String, dynamic>? unbondings}) = _$_OwnStashInfo;
  const _OwnStashInfo._() : super._();

  factory _OwnStashInfo.fromJson(Map<String, dynamic> json) =
      _$_OwnStashInfo.fromJson;

  @override
  LedgerInfo? get account;
  @override
  String? get controllerId;
  @override
  String? get destination;
  @override
  int? get destinationId;
  @override
  Map<String, dynamic>? get exposure;
  @override
  String? get hexSessionIdNext;
  @override
  String? get hexSessionIdQueue;
  @override
  bool? get isOwnController;
  @override
  bool? get isOwnStash;
  @override
  bool? get isStashNominating;
  @override
  bool? get isStashValidating;
  @override
  List<String>? get nominating;
  @override
  List<String>? get sessionIds;
  @override
  Map<String, dynamic>? get stakingLedger;
  @override
  String? get stashId;
  @override
  Map<String, dynamic>? get validatorPrefs;
  @override
  NomineesInfo? get inactives;
  @override
  Map<String, dynamic>? get unbondings;
  @override
  @JsonKey(ignore: true)
  _$OwnStashInfoCopyWith<_OwnStashInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

LedgerInfo _$LedgerInfoFromJson(Map<String, dynamic> json) {
  return _LedgerInfo.fromJson(json);
}

/// @nodoc
class _$LedgerInfoTearOff {
  const _$LedgerInfoTearOff();

  _LedgerInfo call(
      {String? accountId,
      String? controllerId,
      String? stashId,
      Map<String, dynamic>? exposure,
      Map<String, dynamic>? stakingLedger,
      Map<String, dynamic>? validatorPrefs,
      dynamic redeemable = null}) {
    return _LedgerInfo(
      accountId: accountId,
      controllerId: controllerId,
      stashId: stashId,
      exposure: exposure,
      stakingLedger: stakingLedger,
      validatorPrefs: validatorPrefs,
      redeemable: redeemable,
    );
  }

  LedgerInfo fromJson(Map<String, Object?> json) {
    return LedgerInfo.fromJson(json);
  }
}

/// @nodoc
const $LedgerInfo = _$LedgerInfoTearOff();

/// @nodoc
mixin _$LedgerInfo {
  String? get accountId => throw _privateConstructorUsedError;
  String? get controllerId => throw _privateConstructorUsedError;
  String? get stashId => throw _privateConstructorUsedError;
  Map<String, dynamic>? get exposure => throw _privateConstructorUsedError;
  Map<String, dynamic>? get stakingLedger => throw _privateConstructorUsedError;
  Map<String, dynamic>? get validatorPrefs =>
      throw _privateConstructorUsedError;
  dynamic get redeemable => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LedgerInfoCopyWith<LedgerInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LedgerInfoCopyWith<$Res> {
  factory $LedgerInfoCopyWith(
          LedgerInfo value, $Res Function(LedgerInfo) then) =
      _$LedgerInfoCopyWithImpl<$Res>;
  $Res call(
      {String? accountId,
      String? controllerId,
      String? stashId,
      Map<String, dynamic>? exposure,
      Map<String, dynamic>? stakingLedger,
      Map<String, dynamic>? validatorPrefs,
      dynamic redeemable});
}

/// @nodoc
class _$LedgerInfoCopyWithImpl<$Res> implements $LedgerInfoCopyWith<$Res> {
  _$LedgerInfoCopyWithImpl(this._value, this._then);

  final LedgerInfo _value;
  // ignore: unused_field
  final $Res Function(LedgerInfo) _then;

  @override
  $Res call({
    Object? accountId = freezed,
    Object? controllerId = freezed,
    Object? stashId = freezed,
    Object? exposure = freezed,
    Object? stakingLedger = freezed,
    Object? validatorPrefs = freezed,
    Object? redeemable = freezed,
  }) {
    return _then(_value.copyWith(
      accountId: accountId == freezed
          ? _value.accountId
          : accountId // ignore: cast_nullable_to_non_nullable
              as String?,
      controllerId: controllerId == freezed
          ? _value.controllerId
          : controllerId // ignore: cast_nullable_to_non_nullable
              as String?,
      stashId: stashId == freezed
          ? _value.stashId
          : stashId // ignore: cast_nullable_to_non_nullable
              as String?,
      exposure: exposure == freezed
          ? _value.exposure
          : exposure // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      stakingLedger: stakingLedger == freezed
          ? _value.stakingLedger
          : stakingLedger // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      validatorPrefs: validatorPrefs == freezed
          ? _value.validatorPrefs
          : validatorPrefs // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      redeemable: redeemable == freezed
          ? _value.redeemable
          : redeemable // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }
}

/// @nodoc
abstract class _$LedgerInfoCopyWith<$Res> implements $LedgerInfoCopyWith<$Res> {
  factory _$LedgerInfoCopyWith(
          _LedgerInfo value, $Res Function(_LedgerInfo) then) =
      __$LedgerInfoCopyWithImpl<$Res>;
  @override
  $Res call(
      {String? accountId,
      String? controllerId,
      String? stashId,
      Map<String, dynamic>? exposure,
      Map<String, dynamic>? stakingLedger,
      Map<String, dynamic>? validatorPrefs,
      dynamic redeemable});
}

/// @nodoc
class __$LedgerInfoCopyWithImpl<$Res> extends _$LedgerInfoCopyWithImpl<$Res>
    implements _$LedgerInfoCopyWith<$Res> {
  __$LedgerInfoCopyWithImpl(
      _LedgerInfo _value, $Res Function(_LedgerInfo) _then)
      : super(_value, (v) => _then(v as _LedgerInfo));

  @override
  _LedgerInfo get _value => super._value as _LedgerInfo;

  @override
  $Res call({
    Object? accountId = freezed,
    Object? controllerId = freezed,
    Object? stashId = freezed,
    Object? exposure = freezed,
    Object? stakingLedger = freezed,
    Object? validatorPrefs = freezed,
    Object? redeemable = freezed,
  }) {
    return _then(_LedgerInfo(
      accountId: accountId == freezed
          ? _value.accountId
          : accountId // ignore: cast_nullable_to_non_nullable
              as String?,
      controllerId: controllerId == freezed
          ? _value.controllerId
          : controllerId // ignore: cast_nullable_to_non_nullable
              as String?,
      stashId: stashId == freezed
          ? _value.stashId
          : stashId // ignore: cast_nullable_to_non_nullable
              as String?,
      exposure: exposure == freezed
          ? _value.exposure
          : exposure // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      stakingLedger: stakingLedger == freezed
          ? _value.stakingLedger
          : stakingLedger // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      validatorPrefs: validatorPrefs == freezed
          ? _value.validatorPrefs
          : validatorPrefs // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      redeemable: redeemable == freezed
          ? _value.redeemable
          : redeemable // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_LedgerInfo extends _LedgerInfo {
  const _$_LedgerInfo(
      {this.accountId,
      this.controllerId,
      this.stashId,
      this.exposure,
      this.stakingLedger,
      this.validatorPrefs,
      this.redeemable = null})
      : super._();

  factory _$_LedgerInfo.fromJson(Map<String, dynamic> json) =>
      _$$_LedgerInfoFromJson(json);

  @override
  final String? accountId;
  @override
  final String? controllerId;
  @override
  final String? stashId;
  @override
  final Map<String, dynamic>? exposure;
  @override
  final Map<String, dynamic>? stakingLedger;
  @override
  final Map<String, dynamic>? validatorPrefs;
  @JsonKey(defaultValue: null)
  @override
  final dynamic redeemable;

  @override
  String toString() {
    return 'LedgerInfo(accountId: $accountId, controllerId: $controllerId, stashId: $stashId, exposure: $exposure, stakingLedger: $stakingLedger, validatorPrefs: $validatorPrefs, redeemable: $redeemable)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _LedgerInfo &&
            (identical(other.accountId, accountId) ||
                other.accountId == accountId) &&
            (identical(other.controllerId, controllerId) ||
                other.controllerId == controllerId) &&
            (identical(other.stashId, stashId) || other.stashId == stashId) &&
            const DeepCollectionEquality().equals(other.exposure, exposure) &&
            const DeepCollectionEquality()
                .equals(other.stakingLedger, stakingLedger) &&
            const DeepCollectionEquality()
                .equals(other.validatorPrefs, validatorPrefs) &&
            const DeepCollectionEquality()
                .equals(other.redeemable, redeemable));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      accountId,
      controllerId,
      stashId,
      const DeepCollectionEquality().hash(exposure),
      const DeepCollectionEquality().hash(stakingLedger),
      const DeepCollectionEquality().hash(validatorPrefs),
      const DeepCollectionEquality().hash(redeemable));

  @JsonKey(ignore: true)
  @override
  _$LedgerInfoCopyWith<_LedgerInfo> get copyWith =>
      __$LedgerInfoCopyWithImpl<_LedgerInfo>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_LedgerInfoToJson(this);
  }
}

abstract class _LedgerInfo extends LedgerInfo {
  const factory _LedgerInfo(
      {String? accountId,
      String? controllerId,
      String? stashId,
      Map<String, dynamic>? exposure,
      Map<String, dynamic>? stakingLedger,
      Map<String, dynamic>? validatorPrefs,
      dynamic redeemable}) = _$_LedgerInfo;
  const _LedgerInfo._() : super._();

  factory _LedgerInfo.fromJson(Map<String, dynamic> json) =
      _$_LedgerInfo.fromJson;

  @override
  String? get accountId;
  @override
  String? get controllerId;
  @override
  String? get stashId;
  @override
  Map<String, dynamic>? get exposure;
  @override
  Map<String, dynamic>? get stakingLedger;
  @override
  Map<String, dynamic>? get validatorPrefs;
  @override
  dynamic get redeemable;
  @override
  @JsonKey(ignore: true)
  _$LedgerInfoCopyWith<_LedgerInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

NomineesInfo _$NomineesInfoFromJson(Map<String, dynamic> json) {
  return _NomineesInfo.fromJson(json);
}

/// @nodoc
class _$NomineesInfoTearOff {
  const _$NomineesInfoTearOff();

  _NomineesInfo call(
      {List<String>? nomsActive,
      List<String>? nomsChilled,
      List<String>? nomsInactive,
      List<String>? nomsOver,
      List<String>? nomsWaiting}) {
    return _NomineesInfo(
      nomsActive: nomsActive,
      nomsChilled: nomsChilled,
      nomsInactive: nomsInactive,
      nomsOver: nomsOver,
      nomsWaiting: nomsWaiting,
    );
  }

  NomineesInfo fromJson(Map<String, Object?> json) {
    return NomineesInfo.fromJson(json);
  }
}

/// @nodoc
const $NomineesInfo = _$NomineesInfoTearOff();

/// @nodoc
mixin _$NomineesInfo {
  List<String>? get nomsActive => throw _privateConstructorUsedError;
  List<String>? get nomsChilled => throw _privateConstructorUsedError;
  List<String>? get nomsInactive => throw _privateConstructorUsedError;
  List<String>? get nomsOver => throw _privateConstructorUsedError;
  List<String>? get nomsWaiting => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $NomineesInfoCopyWith<NomineesInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NomineesInfoCopyWith<$Res> {
  factory $NomineesInfoCopyWith(
          NomineesInfo value, $Res Function(NomineesInfo) then) =
      _$NomineesInfoCopyWithImpl<$Res>;
  $Res call(
      {List<String>? nomsActive,
      List<String>? nomsChilled,
      List<String>? nomsInactive,
      List<String>? nomsOver,
      List<String>? nomsWaiting});
}

/// @nodoc
class _$NomineesInfoCopyWithImpl<$Res> implements $NomineesInfoCopyWith<$Res> {
  _$NomineesInfoCopyWithImpl(this._value, this._then);

  final NomineesInfo _value;
  // ignore: unused_field
  final $Res Function(NomineesInfo) _then;

  @override
  $Res call({
    Object? nomsActive = freezed,
    Object? nomsChilled = freezed,
    Object? nomsInactive = freezed,
    Object? nomsOver = freezed,
    Object? nomsWaiting = freezed,
  }) {
    return _then(_value.copyWith(
      nomsActive: nomsActive == freezed
          ? _value.nomsActive
          : nomsActive // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      nomsChilled: nomsChilled == freezed
          ? _value.nomsChilled
          : nomsChilled // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      nomsInactive: nomsInactive == freezed
          ? _value.nomsInactive
          : nomsInactive // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      nomsOver: nomsOver == freezed
          ? _value.nomsOver
          : nomsOver // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      nomsWaiting: nomsWaiting == freezed
          ? _value.nomsWaiting
          : nomsWaiting // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ));
  }
}

/// @nodoc
abstract class _$NomineesInfoCopyWith<$Res>
    implements $NomineesInfoCopyWith<$Res> {
  factory _$NomineesInfoCopyWith(
          _NomineesInfo value, $Res Function(_NomineesInfo) then) =
      __$NomineesInfoCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<String>? nomsActive,
      List<String>? nomsChilled,
      List<String>? nomsInactive,
      List<String>? nomsOver,
      List<String>? nomsWaiting});
}

/// @nodoc
class __$NomineesInfoCopyWithImpl<$Res> extends _$NomineesInfoCopyWithImpl<$Res>
    implements _$NomineesInfoCopyWith<$Res> {
  __$NomineesInfoCopyWithImpl(
      _NomineesInfo _value, $Res Function(_NomineesInfo) _then)
      : super(_value, (v) => _then(v as _NomineesInfo));

  @override
  _NomineesInfo get _value => super._value as _NomineesInfo;

  @override
  $Res call({
    Object? nomsActive = freezed,
    Object? nomsChilled = freezed,
    Object? nomsInactive = freezed,
    Object? nomsOver = freezed,
    Object? nomsWaiting = freezed,
  }) {
    return _then(_NomineesInfo(
      nomsActive: nomsActive == freezed
          ? _value.nomsActive
          : nomsActive // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      nomsChilled: nomsChilled == freezed
          ? _value.nomsChilled
          : nomsChilled // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      nomsInactive: nomsInactive == freezed
          ? _value.nomsInactive
          : nomsInactive // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      nomsOver: nomsOver == freezed
          ? _value.nomsOver
          : nomsOver // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      nomsWaiting: nomsWaiting == freezed
          ? _value.nomsWaiting
          : nomsWaiting // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_NomineesInfo extends _NomineesInfo {
  const _$_NomineesInfo(
      {this.nomsActive,
      this.nomsChilled,
      this.nomsInactive,
      this.nomsOver,
      this.nomsWaiting})
      : super._();

  factory _$_NomineesInfo.fromJson(Map<String, dynamic> json) =>
      _$$_NomineesInfoFromJson(json);

  @override
  final List<String>? nomsActive;
  @override
  final List<String>? nomsChilled;
  @override
  final List<String>? nomsInactive;
  @override
  final List<String>? nomsOver;
  @override
  final List<String>? nomsWaiting;

  @override
  String toString() {
    return 'NomineesInfo(nomsActive: $nomsActive, nomsChilled: $nomsChilled, nomsInactive: $nomsInactive, nomsOver: $nomsOver, nomsWaiting: $nomsWaiting)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _NomineesInfo &&
            const DeepCollectionEquality()
                .equals(other.nomsActive, nomsActive) &&
            const DeepCollectionEquality()
                .equals(other.nomsChilled, nomsChilled) &&
            const DeepCollectionEquality()
                .equals(other.nomsInactive, nomsInactive) &&
            const DeepCollectionEquality().equals(other.nomsOver, nomsOver) &&
            const DeepCollectionEquality()
                .equals(other.nomsWaiting, nomsWaiting));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(nomsActive),
      const DeepCollectionEquality().hash(nomsChilled),
      const DeepCollectionEquality().hash(nomsInactive),
      const DeepCollectionEquality().hash(nomsOver),
      const DeepCollectionEquality().hash(nomsWaiting));

  @JsonKey(ignore: true)
  @override
  _$NomineesInfoCopyWith<_NomineesInfo> get copyWith =>
      __$NomineesInfoCopyWithImpl<_NomineesInfo>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_NomineesInfoToJson(this);
  }
}

abstract class _NomineesInfo extends NomineesInfo {
  const factory _NomineesInfo(
      {List<String>? nomsActive,
      List<String>? nomsChilled,
      List<String>? nomsInactive,
      List<String>? nomsOver,
      List<String>? nomsWaiting}) = _$_NomineesInfo;
  const _NomineesInfo._() : super._();

  factory _NomineesInfo.fromJson(Map<String, dynamic> json) =
      _$_NomineesInfo.fromJson;

  @override
  List<String>? get nomsActive;
  @override
  List<String>? get nomsChilled;
  @override
  List<String>? get nomsInactive;
  @override
  List<String>? get nomsOver;
  @override
  List<String>? get nomsWaiting;
  @override
  @JsonKey(ignore: true)
  _$NomineesInfoCopyWith<_NomineesInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

UnbondingInfo _$UnbondingInfoFromJson(Map<String, dynamic> json) {
  return _UnbondingInfo.fromJson(json);
}

/// @nodoc
class _$UnbondingInfoTearOff {
  const _$UnbondingInfoTearOff();

  _UnbondingInfo call({List<dynamic>? mapped, dynamic total = null}) {
    return _UnbondingInfo(
      mapped: mapped,
      total: total,
    );
  }

  UnbondingInfo fromJson(Map<String, Object?> json) {
    return UnbondingInfo.fromJson(json);
  }
}

/// @nodoc
const $UnbondingInfo = _$UnbondingInfoTearOff();

/// @nodoc
mixin _$UnbondingInfo {
  List<dynamic>? get mapped => throw _privateConstructorUsedError;
  dynamic get total => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $UnbondingInfoCopyWith<UnbondingInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UnbondingInfoCopyWith<$Res> {
  factory $UnbondingInfoCopyWith(
          UnbondingInfo value, $Res Function(UnbondingInfo) then) =
      _$UnbondingInfoCopyWithImpl<$Res>;
  $Res call({List<dynamic>? mapped, dynamic total});
}

/// @nodoc
class _$UnbondingInfoCopyWithImpl<$Res>
    implements $UnbondingInfoCopyWith<$Res> {
  _$UnbondingInfoCopyWithImpl(this._value, this._then);

  final UnbondingInfo _value;
  // ignore: unused_field
  final $Res Function(UnbondingInfo) _then;

  @override
  $Res call({
    Object? mapped = freezed,
    Object? total = freezed,
  }) {
    return _then(_value.copyWith(
      mapped: mapped == freezed
          ? _value.mapped
          : mapped // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      total: total == freezed
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }
}

/// @nodoc
abstract class _$UnbondingInfoCopyWith<$Res>
    implements $UnbondingInfoCopyWith<$Res> {
  factory _$UnbondingInfoCopyWith(
          _UnbondingInfo value, $Res Function(_UnbondingInfo) then) =
      __$UnbondingInfoCopyWithImpl<$Res>;
  @override
  $Res call({List<dynamic>? mapped, dynamic total});
}

/// @nodoc
class __$UnbondingInfoCopyWithImpl<$Res>
    extends _$UnbondingInfoCopyWithImpl<$Res>
    implements _$UnbondingInfoCopyWith<$Res> {
  __$UnbondingInfoCopyWithImpl(
      _UnbondingInfo _value, $Res Function(_UnbondingInfo) _then)
      : super(_value, (v) => _then(v as _UnbondingInfo));

  @override
  _UnbondingInfo get _value => super._value as _UnbondingInfo;

  @override
  $Res call({
    Object? mapped = freezed,
    Object? total = freezed,
  }) {
    return _then(_UnbondingInfo(
      mapped: mapped == freezed
          ? _value.mapped
          : mapped // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      total: total == freezed
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_UnbondingInfo extends _UnbondingInfo {
  const _$_UnbondingInfo({this.mapped, this.total = null}) : super._();

  factory _$_UnbondingInfo.fromJson(Map<String, dynamic> json) =>
      _$$_UnbondingInfoFromJson(json);

  @override
  final List<dynamic>? mapped;
  @JsonKey(defaultValue: null)
  @override
  final dynamic total;

  @override
  String toString() {
    return 'UnbondingInfo(mapped: $mapped, total: $total)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UnbondingInfo &&
            const DeepCollectionEquality().equals(other.mapped, mapped) &&
            const DeepCollectionEquality().equals(other.total, total));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(mapped),
      const DeepCollectionEquality().hash(total));

  @JsonKey(ignore: true)
  @override
  _$UnbondingInfoCopyWith<_UnbondingInfo> get copyWith =>
      __$UnbondingInfoCopyWithImpl<_UnbondingInfo>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_UnbondingInfoToJson(this);
  }
}

abstract class _UnbondingInfo extends UnbondingInfo {
  const factory _UnbondingInfo({List<dynamic>? mapped, dynamic total}) =
      _$_UnbondingInfo;
  const _UnbondingInfo._() : super._();

  factory _UnbondingInfo.fromJson(Map<String, dynamic> json) =
      _$_UnbondingInfo.fromJson;

  @override
  List<dynamic>? get mapped;
  @override
  dynamic get total;
  @override
  @JsonKey(ignore: true)
  _$UnbondingInfoCopyWith<_UnbondingInfo> get copyWith =>
      throw _privateConstructorUsedError;
}
